{"/home/travis/build/npmtest/node-npmtest-rho/test.js":"/* istanbul instrument in package npmtest_rho */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rho/lib.npmtest_rho.js":"/* istanbul instrument in package npmtest_rho */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_rho = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_rho = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-rho/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-rho && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_rho */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_rho\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_rho.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_rho.rollup.js'] =\n            local.assetsDict['/assets.npmtest_rho.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_rho.__dirname + '/lib.npmtest_rho.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/rho.js":"'use strict';\n\nvar defaults = require(\"./defaults\")\n  , BlockCompiler = require(\"./block\")\n  , InlineCompiler = require(\"./inline\")\n  , AsyncCompiler = require(\"./async\")\n  , walklib = require(\"./walker.js\");\n\n/* # Rho module\n\nTo minimize usage efforts Rho can be configured globally for your application.\n\n```\n// Require the module first\nvar rho = require(\"rho\");\n\n// This is the text we will be rendering\nvar text = \"Hello\\n\\n*World*!\";\n\n// Asynchronous API (preferable in web applications)\nrho.render(text, function(err, html) {\n  // html now contains \"<p>Hello</p><p><strong>World</strong>!</p>\"\n});\n\n// Synchronous API (still fast, but cause a bit of blocking)\nvar html = rho.toHtml(text);\n// html now contains \"<p>Hello</p><p><strong>World</strong>!</p>\"\n\n// Inline compilation, synchronous only\n var inline = rho.toInlineHtml(text);\n // inline now contains \"Hello\\n\\n<strong>World</strong>!\"\n```\n\nIf you intent to use different configurations in a single application,\nstick with either `BlockCompiler`, `InlineCompiler` or `AsyncCompiler`.\n*/\nmodule.exports = exports = {\n\n  options: defaults.options,\n\n  toHtml: function(text, pretty) {\n    var result = new BlockCompiler(this.options).toHtml(text);\n    if (pretty)\n      result = require(\"html\").prettyPrint(result, { indent_size: 2 }) + \"\\n\";\n    return result;\n  },\n\n  toInlineHtml: function(text) {\n    return new InlineCompiler(this.options).toHtml(text);\n  },\n\n  render: function(text, done) {\n    new AsyncCompiler(this.options).render(text, done);\n  },\n\n  InlineCompiler: InlineCompiler,\n  BlockCompiler: BlockCompiler,\n  AsyncCompiler: AsyncCompiler,\n  Walker: walklib.Walker,\n  SubWalker: walklib.SubWalker,\n  MultiWalker: walklib.MultiWalker,\n  defaults: defaults\n\n};\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/defaults.js":"\"use strict\";\n\nexports.options = {\n\n  resolveLink: function(id) {\n    return null;\n  },\n\n  resolveImage: function(id) {\n    return null;\n  },\n\n  stripInvalidXmlChars: true,\n\n  typographics: {\n\n    enabled: true,\n\n    mdash: \"&mdash;\",\n    copy: \"&copy;\",\n    reg: \"&reg;\",\n    trade: \"&trade;\",\n    larr: \"&larr;\",\n    rarr: \"&rarr;\",\n    ldquo: \"&ldquo;\",\n    rdquo: \"&rdquo;\"\n\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/block.js":"\"use strict\";\n\nvar defaults = require(\"./defaults\")\n  , InlineCompiler = require(\"./inline\")\n  , Walker = require(\"./walker\").Walker\n  , SubWalker = require(\"./walker\").SubWalker;\n\n/* # Block compiler\n\n Block compiler is what you usually use to transform a document.\n It walks a potentially large documents coarsely, looking for\n markers which designate the block. The inline markup (inside\n blocks) is processed by `InlineCompiler`.\n */\nvar BlockCompiler\n  = module.exports\n  = exports\n  = function(options) {\n\n  this.options = require(\"./extend\")({}, defaults.options, options);\n\n  this.reset();\n\n};\n\n/* ## Compilation\n\n Block compiler follows the conventions of `InlineCompiler`:\n\n * `tryXXX` methods are \"fail-fast\" and immediately return `false`,\n if they do not match the start of the block;\n * `emitXXX` methods do not return meaningful result; instead, they\n modify the output and increment the cursor position.\n\n */\nBlockCompiler.prototype = {\n\n  InlineCompiler: InlineCompiler,\n\n  toHtml: function(input) {\n    return this.reset().append(input).outToString();\n  },\n\n  reset: function() {\n    this.out = [];\n    this.selector = {};\n    this.blockIndent = 0;\n    this.inline = new this.InlineCompiler(this.options, this);\n    this.inline.out = this.out;\n    return this;\n  },\n\n  append: function(input) {\n    return this.processBlocks(new Walker(input));\n  },\n\n  processBlocks: function(walk) {\n    while(walk.hasCurrent())\n      this.emitBlock(walk);\n    return this;\n  },\n\n  outToString: function() {\n    var result = \"\";\n    for (var i = 0; i < this.out.length; i++)\n      result += this.out[i];\n    return result;\n  },\n\n  emitBlock: function(walk) {\n    walk.skipBlankLines();\n    this.countBlockIndent(walk);\n    if (this.tryUnorderedList(walk)) return;\n    if (this.tryOrderedList(walk)) return;\n    if (this.tryDefinitionList(walk)) return;\n    if (this.tryHeading(walk)) return;\n    if (this.tryCodeBlock(walk)) return;\n    if (this.tryDiv(walk)) return;\n    if (this.tryHtml(walk)) return;\n    if (this.tryHrTable(walk)) return;\n    this.emitParagraph(walk);\n  },\n\n  // Uses inline compiler to emit output of specified walk.\n\n  emitInline: function(walk) {\n    this.inline.processInlines(walk);\n    return this;\n  },\n\n  /* Counts the spaces from line start up to the first non-whitespace char\n   on the first line of a block. */\n\n  countBlockIndent: function(walk) {\n    this.blockIndent = 0;\n    while (walk.hasCurrent() && walk.at(\" \")) {\n      this.blockIndent += 1;\n      walk.skip();\n    }\n  },\n\n  /* Selector expression is stripped from each block, if it exists,\n   resulting in a new walker with excluded region. */\n  stripSelector: function(walk, allowMultipleSelectors) {\n    this.selector = {};\n    var start = walk.position;\n    while (walk.hasCurrent() && !walk.atNewLine()) {\n      if (walk.at(\"\\\\{\")) {\n        walk.skip(2);\n        continue;\n      }\n      if (walk.at(\"{\")) {\n        var s = walk.position;\n        walk.skip();\n        this.trySelectorId(walk);\n        while(this.trySelectorClass(walk)) {}\n        this.trySelectorStyle(walk);\n        if (!walk.at(\"}\")) // invalid selector\n          break;\n        // Selector matched, exclude it\n        walk.skip().skipSpaces();\n        // Only match if the selector was at the end of the line\n        // or we allow multiple selectors on a line and the next char is \"{\"\n        if (!walk.hasCurrent() || walk.atNewLine() || (allowMultipleSelectors && walk.at(\"{\"))) {\n          var e = walk.position;\n          return walk.startFrom(start).exclude(s, e);\n        }\n      } else walk.skip();\n    }\n    // Selector not found\n    this.selector = {};\n    walk.startFrom(start);\n    return walk;\n  },\n\n  trySelectorId: function(walk) {\n    if (!walk.at(\"#\")) return false;\n    walk.skip();\n    var end = walk.lookahead(function(w) {\n      while (w.hasCurrent() && w.atIdentifier())\n        w.skip();\n      return w.position;\n    });\n    this.selector.id = walk.yieldUntil(end);\n    return true;\n  },\n\n  trySelectorStyle: function(walk) {\n    if (!walk.at(\";\")) return false;\n    walk.skip();\n    var end = walk.lookahead(function(w) {\n      while (w.hasCurrent() && !w.at('}'))\n        w.skip();\n      return w.position;\n    });\n    this.selector.style = walk.yieldUntil(end);\n    return true;\n  },\n\n  trySelectorClass: function(walk) {\n    if (!walk.at(\".\")) return false;\n    walk.skip();\n    var end = walk.lookahead(function(w) {\n      while (w.hasCurrent() && w.atIdentifier())\n        w.skip();\n      return w.position;\n    });\n    if (!Array.isArray(this.selector.classes))\n      this.selector.classes = [];\n    this.selector.classes.push(walk.yieldUntil(end));\n    return true;\n  },\n\n  /* Selector is emitted as HTML `id` and `class` attributes. */\n\n  emitSelector: function() {\n    // emit id\n    if (typeof this.selector.id == \"string\") {\n      this.out.push(\" id=\\\"\" + this.selector.id + \"\\\"\");\n    }\n    // emit style\n    if (typeof this.selector.style == \"string\") {\n      this.out.push(\" style=\\\"\" + this.selector.style + \"\\\"\");\n    }\n    // emit class\n    if (Array.isArray(this.selector.classes)) {\n      this.out.push(\" class=\\\"\");\n      var totalSel = this.selector.classes.length;\n      for (var i = 0; i < totalSel; i++) {\n        if (i > 0) this.out.push(\" \");\n        this.out.push(this.selector.classes[i]);\n      }\n      this.out.push(\"\\\"\");\n    }\n  },\n\n  /* Markered blocks are DIVs `~~~` and code blocks `\\`\\`\\``. */\n\n  tryCodeBlock: function(walk) {\n    if (!walk.at(\"```\")) return false;\n    walk.skip(3);\n    var startIdx = walk.position;\n    var endIdx = walk.indexOf(\"```\");\n    if (endIdx === null) {\n      // Not a code block\n      walk.startFrom(startIdx - 3);\n      return false;\n    }\n    var b = this.stripSelector(new SubWalker(walk, startIdx, endIdx));\n    this.out.push(\"<pre\");\n    this.emitSelector();\n    this.out.push(\"><code>\");\n    this.emitCode(b);\n    this.out.push(\"</code></pre>\");\n    walk.startFrom(endIdx + 3).skipBlankLines();\n    return true;\n  },\n\n  /* Code is processed line-by-line, block indent is stripped. */\n\n  emitCode: function(walk) {\n    walk.skipBlankLines();\n    if (walk.atSpaces(this.blockIndent))\n      walk.skip(this.blockIndent);\n    while (walk.hasCurrent()) {\n      if (walk.atNewLine()) {\n        walk.skipNewLine();\n        if (walk.atSpaces(this.blockIndent))\n          walk.skip(this.blockIndent);\n        if (walk.hasCurrent())\n          this.out.push(\"\\n\");\n      } else {\n        this.inline.emitCode(walk);\n      }\n    }\n  },\n\n  /* Divs are simple blocks surrounded by `~~~`. They are extremely\n   useful if you wish to attach a class to several blocks without\n   changing their semantics. */\n\n  tryDiv: function(walk) {\n    if (!walk.at(\"~~~\")) return false;\n    walk.skip(3);\n    var startIdx = walk.position;\n    var endIdx = walk.indexOf(\"~~~\");\n    if (endIdx === null) {\n      // Not a div\n      walk.startFrom(startIdx - 3);\n      return false;\n    }\n    var b = this.stripSelector(new SubWalker(walk, startIdx, endIdx));\n    this.out.push(\"<div\");\n    this.emitSelector();\n    this.out.push(\">\");\n    while (b.hasCurrent())\n      this.emitBlock(b);\n    this.out.push(\"</div>\\n\");\n    walk.startFrom(endIdx + 3).skipBlankLines();\n    return true;\n  },\n\n  /* Unordered lists start with `* `, every line indented beyond\n   the marker is included into `<li>`.*/\n\n  tryUnorderedList: function(walk) {\n    if (!walk.at(\"* \")) return false;\n    var startIdx = walk.position;\n    var found = false;\n    // Find the end of the block, checking for nested subblocks\n    while (!found && walk.hasCurrent()) {\n      walk.scrollToTerm().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent)) {\n        var i = walk.position;\n        walk.skip(this.blockIndent);\n        if (!walk.at(\"* \") && !walk.atSpace()) {\n          found = true;\n          walk.startFrom(i);\n        }\n      } else found = true;\n    }\n    // We got UL region, emit it\n    var ul = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n    this.emitUl(ul);\n    return true;\n  },\n\n  emitUl: function(walk) {\n    this.out.push(\"<ul\");\n    this.emitSelector();\n    this.out.push(\">\");\n    // Determining the bounds of each li\n    walk.skip(2); // Skipping marker\n    var startIdx = walk.position;\n    while (walk.hasCurrent()) {\n      walk.scrollToEol().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent) &&\n        walk.skip(this.blockIndent).at(\"* \")) {\n        var li = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n        this.emitLi(li);\n        // Skip next marker\n        walk.skip(2);\n        startIdx = walk.position;\n      }\n    }\n    // Emit last li\n    var last = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n    this.emitLi(last);\n    // All items emitted\n    this.out.push(\"</ul>\\n\");\n  },\n\n  /* Ordered lists start with `1. ` and continue with any-digit marker. */\n\n  tryOrderedList: function(walk) {\n    if (!walk.at(\"1. \")) return false;\n    var startIdx = walk.position;\n    var found = false;\n    // Find the end of the block, checking for nested subblocks\n    while (!found && walk.hasCurrent()) {\n      walk.scrollToTerm().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent)) {\n        var i = walk.position;\n        walk.skip(this.blockIndent);\n        if (!this.lookingAtOlMarker(walk) && !walk.atSpace()) {\n          found = true;\n          walk.startFrom(i);\n        }\n      } else found = true;\n    }\n    // We got UL region, emit it\n    var ol = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n    this.emitOl(ol);\n    return true;\n  },\n\n  lookingAtOlMarker: function(walk) {\n    if (!walk.atDigit()) return false;\n    return walk.lookahead(function(w) {\n      while (w.atDigit())\n        w.skip();\n      return w.at(\". \");\n    });\n  },\n\n  emitOl: function(walk) {\n    this.out.push(\"<ol\");\n    this.emitSelector();\n    this.out.push(\">\");\n    // Determining the bounds of each li\n    walk.skipDigits().skip(2); // Skipping marker\n    var startIdx = walk.position;\n    while (walk.hasCurrent()) {\n      walk.scrollToEol().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent) &&\n        this.lookingAtOlMarker(walk.skip(this.blockIndent))) {\n        var li = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n        this.emitLi(li);\n        // Skip next marker\n        walk.skipDigits().skip(2);\n        startIdx = walk.position;\n      }\n    }\n    // Emit last li\n    var last = this.stripSelector(new SubWalker(walk, startIdx, walk.position), true);\n    this.emitLi(last);\n    // All items emitted\n    this.out.push(\"</ol>\\n\");\n  },\n\n  // LI emitting is universal -- both for OLs and ULs.\n\n  emitLi: function(walk) {\n    this.out.push(\"<li\");\n    this.emitSelector();\n    this.out.push(\">\");\n    // Determine, whether the contents is inline or block\n    var b = walk.lookahead(function(w) {\n      w.scrollToTerm().skipWhitespaces();\n      return w.hasCurrent(); // In other words, there is a blank line inside\n    });\n    var indent = this.blockIndent;\n    if (b) {\n      while (walk.hasCurrent())\n        this.emitBlock(walk);\n      this.blockIndent = indent;\n    } else this.emitInline(walk);\n    this.out.push(\"</li>\");\n  },\n\n  /* Definition lists start with either `= ` or `- ` which are rendered as\n  `dt` and `dd` respectively. Indentation is required for nested blocks. */\n\n  tryDefinitionList: function(walk) {\n    if (!walk.at(\"= \") && !walk.at('- ')) return false;\n    var startIdx = walk.position;\n    var found = false;\n    // Find the end of the block, checking for nested subblocks\n    while (!found && walk.hasCurrent()) {\n      walk.scrollToTerm().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent)) {\n        var i = walk.position;\n        walk.skip(this.blockIndent);\n        if (!walk.at(\"= \") && !walk.at('- ') && !walk.atSpace()) {\n          found = true;\n          walk.startFrom(i);\n        }\n      } else found = true;\n    }\n    // We got DL region, emit it\n    var dl = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n    this.emitDl(dl);\n    return true;\n  },\n\n  emitDl: function(walk) {\n    this.out.push(\"<dl\");\n    this.emitSelector();\n    this.out.push(\">\");\n    // Parsing dt and dd\n    var startIdx = walk.position;\n    while (walk.hasCurrent()) {\n      walk.scrollToEol().skipBlankLines();\n      if (walk.atSpaces(this.blockIndent)) {\n        walk.skip(this.blockIndent);\n        if (walk.at('= ') || walk.at('- ')) {\n          var elem = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n          this.emitDtDd(elem);\n          startIdx = walk.position;\n        }\n      }\n    }\n    // Emit last element\n    var last = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n    this.emitDtDd(last);\n    // All items emitted\n    this.out.push(\"</dl>\\n\");\n  },\n\n  // emits either `dt` or `dd` depending on the marker\n\n  emitDtDd: function(walk) {\n    var tag = walk.at('= ') ? 'dt' : 'dd';\n    walk.skip(2);\n    this.out.push(\"<\");\n    this.out.push(tag);\n    this.emitSelector();\n    this.out.push(\">\");\n    // Determine, whether the contents is inline or block\n    var b = walk.lookahead(function(w) {\n      w.scrollToTerm().skipWhitespaces();\n      return w.hasCurrent(); // In other words, there is a blank line inside\n    });\n    var indent = this.blockIndent;\n    if (b) {\n      while (walk.hasCurrent())\n        this.emitBlock(walk);\n      this.blockIndent = indent;\n    } else this.emitInline(walk);\n    this.out.push('</');\n    this.out.push(tag);\n    this.out.push('>');\n  },\n\n  /* Headings start with `#`, the amount of pounds designate the level. */\n\n  tryHeading: function(walk) {\n    if (!walk.at(\"#\")) return false;\n    var startIdx = walk.position;\n    var level = 0;\n    while (walk.at(\"#\")) {\n      walk.skip();\n      level += 1;\n    }\n    if (!walk.at(\" \")) {\n      walk.startFrom(startIdx);\n      return false;\n    }\n    // This is heading now, emitting inplace\n    var tag = \"h\" + level.toString();\n    walk.skip();\n    startIdx = walk.position;\n    walk.scrollToTerm();\n    var h = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n    this.out.push(\"<\");\n    this.out.push(tag);\n    this.emitSelector();\n    this.out.push(\">\");\n    this.emitInline(h);\n    this.out.push(\"</\");\n    this.out.push(tag);\n    this.out.push(\">\");\n    return true;\n  },\n\n  /* Block HTML tags are emitted without much of modification. */\n\n  tryHtml: function(walk) {\n    if (!walk.at(\"<\")) return false;\n    var endIdx = walk.indexOf(\">\");\n    if (endIdx === null) {\n      return false;\n    }\n    var tag = walk.substring(walk.position, endIdx + 1);\n    // Attempt to match a tag\n    var m = htmlTagRe.exec(tag);\n    if (m === null) {\n      // Try HTML comment as well\n      if (htmlCommentRe.test(tag)) {\n        this.out.push(tag);\n        walk.startFrom(endIdx + 1).skipBlankLines();\n        return true;\n      }\n      // Not HTML block or comment\n      return false;\n    }\n    // Only block tags are accepted\n    var tagName = m[1].toLowerCase();\n    if (inlineTags.indexOf(tagName) !== -1) {\n      // Seems like it's a paragraph starting with inline element\n      return false;\n    }\n    // Search for corresponding closing tag\n    var startIdx = walk.position;\n    walk.startFrom(endIdx);\n    this.scrollToClosingTag(walk, tagName);\n    var w = new SubWalker(walk, startIdx, walk.position);\n    while (w.hasCurrent())\n      this.inline.emitPlain(w);\n    return true;\n  },\n\n  scrollToClosingTag: function(walk, tagName) {\n    var openingTag = \"<\" + tagName;\n    var closingTag = \"</\" + tagName;\n    var found = false;\n    while (!found && walk.hasCurrent()) {\n      // Closing tag\n      if (walk.atInsensitive(closingTag)) {\n        walk.skip(closingTag.length).scrollTo(\">\").skip();\n        return;\n      }\n      // Opening tag: skipping it and search recursively\n      if (walk.atInsensitive(openingTag)) {\n        walk.skip(openingTag.length).scrollTo(\">\").skip();\n        this.scrollToClosingTag(walk, tagName);\n        continue;\n      }\n      // All other cases\n      walk.skip();\n    }\n  },\n\n  /* HRs and tables start with `---`. Their latter contents is ran through\n   regex.*/\n\n  tryHrTable: function(walk) {\n    if (!walk.at(\"---\")) return false;\n    var startIdx = walk.position;\n    walk.scrollToTerm();\n    var b = this.stripSelector(new SubWalker(walk, startIdx, walk.position));\n    if (b.toString().trim() == \"---\")\n      this.emitHr(b);\n    else this.emitTable(b);\n    return true;\n  },\n\n  emitHr: function(walk) {\n    this.out.push(\"<hr\");\n    this.emitSelector();\n    this.out.push(\"/>\");\n  },\n\n  emitTable: function(walk) {\n    var $this = this;\n    this.out.push(\"<table\");\n    this.emitSelector();\n    // Scan for width marker at the end of initial `-`-sequence\n    while (walk.at(\"-\")) walk.skip();\n    if (walk.at(\">\")) {\n      this.out.push(\" width=\\\"100%\\\"\");\n      walk.skip();\n    }\n    this.out.push(\">\");\n    // Columns count is determined by reading the first line\n    walk.skipWhitespaces();\n    var cells = this.readCells(walk.readLine());\n    var cols = cells.length;\n    var alignAttrs = [];\n    var hasHead = false;\n    // Scan the next line for alignment data, if it looks like separator line\n    var line = walk.readLine();\n    if (tableSeparatorLineRe.test(line.toString().trim())) {\n      hasHead = true;\n      // stash selector, b/c it is overwritten by readCells\n      var selector = this.selector;\n      var separators = this.readCells(line);\n      this.selector = selector;\n      separators.forEach(function(e, i) {\n        var m = e.trim();\n        var left = m[0] == \":\";\n        var right = m[m.length - 1] == \":\";\n        if (left && right) alignAttrs[i] = \" class=\\\"align-center\\\"\";\n        else if (left) alignAttrs[i] = \" class=\\\"align-left\\\"\";\n        else if (right) alignAttrs[i] = \" class=\\\"align-right\\\"\";\n      });\n    }\n    // Emitting head\n    if (hasHead) {\n      this.out.push(\"<thead>\");\n      this.emitRow(\"th\", cells, alignAttrs);\n      this.out.push(\"</thead>\");\n    }\n    // Emitting body\n    this.out.push(\"<tbody>\");\n    var found = false;\n    if (!hasHead) {\n      // Don't forget that first row!\n      this.emitRow(\"td\", cells, alignAttrs);\n      // Also process the buffered line\n      found = processLine();\n    }\n    while (!found && walk.hasCurrent()) {\n      walk.skipWhitespaces();\n      line = walk.readLine();\n      found = processLine();\n    }\n    this.out.push(\"</tbody>\");\n    this.out.push(\"</table>\");\n\n    function processLine() {\n      if (tableEndRe.test(line.toString().trim()))\n        return true;\n      var cells = $this.readCells(line);\n      while (cells.length > cols)\n        cells.pop();\n      while (cells.length < cols)\n        cells.push(\"\");\n      $this.emitRow(\"td\", cells, alignAttrs);\n      return false;\n    }\n\n  },\n\n  emitRow: function(tag, cells, alignAttrs) {\n    this.out.push(\"<tr\");\n    this.emitSelector();\n    this.out.push(\">\");\n    for (var i = 0; i < cells.length; i++) {\n      var cell = cells[i];\n      var a = alignAttrs[i];\n      this.out.push(\"<\");\n      this.out.push(tag);\n      if (a) this.out.push(a);\n      this.out.push(\">\");\n      if (cell.length)\n        this.emitInline(new Walker(cell));\n      this.out.push(\"</\");\n      this.out.push(tag);\n      this.out.push(\">\");\n    }\n    this.out.push(\"</tr>\");\n  },\n\n  // Columns are read line-by-line, cells are delimited with `|`\n\n  readCells: function(walk) {\n    walk = this.stripSelector(walk);\n    var result = [];\n    walk.skipWhitespaces();\n    // Skipping leading pipe\n    if (walk.at(\"|\")) walk.skip();\n    var i = walk.position;\n    while (walk.hasCurrent() && !walk.atNewLine()) {\n      // Respect backslash escape `\\\\|`\n      if (walk.at(\"\\\\|\"))\n        walk.skip(2);\n      else if (walk.at(\"|\")) {\n        result.push(walk.substring(i, walk.position));\n        walk.skip();\n        i = walk.position;\n      } else walk.skip();\n    }\n    // Don't forget the last cell\n    var s = walk.substring(i, walk.position).trim();\n    if (s != \"\")\n      result.push(s);\n    // Skip trailing whitespace\n    walk.skipWhitespaces();\n    return result;\n  },\n\n  /* Paragraph is the most generic block. It is emitted if\n   other blocks did not match. */\n\n  emitParagraph: function(walk) {\n    if (walk.hasCurrent()) {\n      var start = walk.position;\n      walk.scrollToTerm();\n      var p = this.stripSelector(new SubWalker(walk, start, walk.position));\n      this.out.push(\"<p\");\n      this.emitSelector();\n      this.out.push(\">\");\n      this.emitInline(p);\n      this.out.push(\"</p>\\n\");\n    }\n  }\n\n};\n\n/* ## Constants */\nvar inlineTags = [\"a\", \"b\", \"big\", \"i\", \"small\", \"tt\", \"abbr\", \"acronym\",\n  \"cite\", \"code\", \"dfn\", \"em\", \"kbd\", \"strong\", \"samp\", \"time\", \"var\",\n  \"a\", \"bdo\", \"br\", \"img\", \"map\", \"object\", \"q\", \"script\", \"span\", \"sub\",\n  \"sup\", \"button\", \"input\", \"label\", \"select\", \"textarea\"];\n\nvar htmlTagRe = /^<\\/?([a-zA-Z][a-zA-Z-]*)\\b[\\s\\S]*?(\\/)?>$/;\nvar htmlCommentRe = /^<!--[\\s\\S]*?-->$/;\n\nvar tableSeparatorLineRe = /^[- :|]+$/;\nvar tableEndRe = /^-{3,}$/;\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/inline.js":"\"use strict\";\n\nvar defaults = require(\"./defaults\")\n  , Walker = require(\"./walker\").Walker\n  , SubWalker = require(\"./walker\").SubWalker;\n\n/* # Inline compiler\n\n Inline compiler transforms text within blocks by applying\n typographic enhancements, escaping unsafe HTML and XML chars,\n expanding inline elements syntax, including `em`, `strong`,\n `code`, `a`, etc.\n */\nvar InlineCompiler\n  = module.exports\n  = exports\n  = function(options) {\n\n  this.options = require(\"./extend\")({}, defaults.options, options);\n\n  this.reset();\n\n};\n\n/* ## Compilation\n\n Compilation is done by series of `tryXXX` alongside with `emitXXX`\n methods.\n\n `tryXXX` probe input at current position to match some tokens specific\n for `XXX` markup element.\n\n `tryXXX` methods are designed for fail-fast: if the input don't match,\n they immediately return `false`, leaving the cursor unmodified.\n However, if they match, they become responsible for emitting an element.\n When `tryXXX` returns `true`, the input cursor is positioned at the end\n of `XXX`.\n\n `emitXXX` are designed to emit unconditionally, thus they do not return\n anything meaningful.\n */\nInlineCompiler.prototype = {\n\n  toHtml: function(input) {\n    return this.reset().append(input).outToString();\n  },\n\n  reset: function() {\n    this.out = [];\n    return this;\n  },\n\n  append: function(input) {\n    return this.processInlines(new Walker(input));\n  },\n\n  processInlines: function(walk) {\n    while(walk.hasCurrent())\n      this.emitNormal(walk);\n    return this;\n  },\n\n  outToString: function() {\n    var result = \"\";\n    for (var i = 0; i < this.out.length; i++)\n      result += this.out[i];\n    return result;\n  },\n\n  /* ## Compiler contexts\n\n   Inline compiler operates in following contexts:\n\n   * normal — all tokens are processed as in specification;\n   * code — only backslash escapes and HTML chars are processed;\n   * plain — only ampersand-escapes are processed.\n\n   */\n  emitNormal: function(walk) {\n    if (this.emitText(walk)) return;\n    // Backslash escapes\n    if (this.tryBackslashEscape(walk)) return;\n    // Typographics\n    if (this.options.typographics.enabled &&\n      this.tryTypographics(walk))\n      return;\n    // HTML chars\n    if (this.tryAmp(walk)) return;\n    if (this.tryLt(walk)) return;\n    if (this.tryGt(walk)) return;\n    // Bracing elements\n    if (this.tryTripleCodeSpan(walk)) return;\n    if (this.tryCodeSpan(walk)) return;\n    if (this.tryFormula(walk)) return;\n    if (this.tryEm(walk)) return;\n    if (this.tryStrong(walk)) return;\n    // Link, media, fragments\n    if (this.tryHeadlessLink(walk)) return;\n    if (this.tryLink(walk)) return;\n    if (this.tryImg(walk)) return;\n    // General character\n    this.emitChar(walk);\n  },\n\n  /* Chars are spit \"as is\", only XML-invalid chars are filtered. */\n  emitChar: function(walk) {\n    var c = walk.current();\n    if (!(this.options.stripInvalidXmlChars && isInvalidXmlChar(c)))\n      this.out.push(c);\n    walk.skip();\n  },\n\n  emitText: function(walk) {\n    var t = walk.yieldText();\n    if (t.length > 0)\n      this.out.push(t);\n    return !walk.hasCurrent();\n  },\n\n  /* Reserved char are backslash-escaped. */\n  tryBackslashEscape: function(walk) {\n    if (!walk.at(\"\\\\\"))\n      return false;\n    // Assuming backslash\n    walk.skip();\n    if (walk.matchSome(backslashChars)) {\n      this.out.push(walk.current());\n      walk.skip();\n    } else {\n      this.out.push(\"\\\\\");\n    }\n    return true;\n  },\n\n  tryTypographics: function(walk) {\n    if (walk.at(\"--\")) {\n      walk.skip(2);\n      this.out.push(this.options.typographics.mdash);\n      return true;\n    } else if (walk.at(\"(c)\") || walk.at(\"(C)\")) {\n      walk.skip(3);\n      this.out.push(this.options.typographics.copy);\n      return true;\n    } else if (walk.at(\"(r)\") || walk.at(\"(R)\")) {\n      walk.skip(3);\n      this.out.push(this.options.typographics.reg);\n      return true;\n    } else if (walk.at(\"(tm)\") || walk.at(\"(TM)\")) {\n      walk.skip(4);\n      this.out.push(this.options.typographics.trade);\n      return true;\n    } else if (walk.at(\"<-\")) {\n      walk.skip(2);\n      this.out.push(this.options.typographics.larr);\n      return true;\n    } else if (walk.at(\"&lt;-\")) {\n      walk.skip(5);\n      this.out.push(this.options.typographics.larr);\n      return true;\n    } else if (walk.at(\"->\")) {\n      walk.skip(2);\n      this.out.push(this.options.typographics.rarr);\n      return true;\n    } else if (walk.at(\"-&gt;\")) {\n      walk.skip(5);\n      this.out.push(this.options.typographics.rarr);\n      return true;\n    } else if (walk.at(\"\\\"\")) {\n      walk.skip();\n      var lastToken = this.out[this.out.length - 1] || \"\";\n      var lastChar = lastToken[lastToken.length - 1] || \"\";\n      if (lastChar.trim() == \"\")\n        this.out.push(this.options.typographics.ldquo);\n      else this.out.push(this.options.typographics.rdquo);\n      return true;\n    }\n    return false;\n  },\n\n  /* Ampersands should distinguish entity references. */\n\n  tryAmp: function(walk) {\n    if (!walk.at(\"&\")) return false;\n    // Assuming entity reference\n    var end = walk.lookahead(function(w) {\n      // Skipping &\n      walk.skip();\n      var allowedChars = latinLetters;\n      if (walk.matchSome([\"#x\", \"#X\"])) {\n        allowedChars = hexChars;\n        walk.skip(2);\n      } else if (walk.at(\"#\")) {\n        allowedChars = decimalChars;\n        walk.skip();\n      }\n      // We are standing at the first char of entity reference code\n      if (w.current() == \";\")  // zero-length references disallowed\n        return null;\n      while (w.hasCurrent()) {\n        var c = w.current();\n        if (c == \";\") {\n          w.skip();\n          return w.position;\n        } else if (w.matchSome(allowedChars)) {\n          w.skip();\n        } else return null;\n      }\n      return null;\n    });\n    // Entity reference is emitted as is\n    if (end !== null) {\n      this.out.push(walk.yieldUntil(end));\n    } else {\n      // Escaping as &amp;\n      this.out.push(\"&amp;\");\n      walk.skip();\n    }\n    return true;\n  },\n\n  /* The `<` char should be escaped, unless it is a part of HTML tag. */\n\n  tryLt: function(walk) {\n    if (!walk.at(\"<\")) return false;\n    if (this.tryHtmlTag(walk)) return true;\n    if (this.tryHtmlComment(walk)) return true;\n    // Not HTML tag -- escaping <\n    this.out.push(\"&lt;\");\n    walk.skip();\n    return true;\n  },\n\n  /* HTML tags and comments are emitted without much of modification\n   (only amps are processed inside). A word of a caution, though.\n\n   HTML tag is rather coarsely determined: we look for `<`,\n   then optional `/` (in case this is a close tag); then\n   latin word -- tag name. If matching is successful up to this point,\n   we start looking for the sequence which closes this tag (`>` or `/>`).\n\n   This leads to unexpected behaviour, if you have an input like\n   `A<B *hello* A>B`, which you would expect to compile like\n   `A&lt;B <strong>hello</strong> A&gt;B`. Due to our coarse HTML detection\n   the `<B *hello* A>` sequence is considered a HTML tag, thus is left\n   unprocessed.\n\n   Most of the time this is totally OK, however. The `<` chars are not\n   encountered that much in plain texts, and when they do, they are usually:\n\n   * a part of MathJAX expression (inside `%%` or `$$`);\n   * a part of code block or code span;\n   * delimited from words with spaces.\n\n   In all of these cases it will be escaped as `&lt;`, comme il faut.\n\n   */\n\n  tryHtmlTag: function(walk) {\n    var end = walk.lookahead(function(w) {\n      w.skip();\n      // Closing tags count\n      if (w.at(\"/\"))\n        w.skip();\n      // Tag name should start with latin\n      if (!w.atLatin())\n        return null;\n      while(w.atLatin())\n        w.skip();\n      // Tag name skipped, now search for either /> or >\n      while(w.hasCurrent()) {\n        if (w.at(\">\")) {\n          w.skip();\n          return w.position;\n        } else if (w.at(\"/>\")) {\n          w.skip(2);\n          return w.position;\n        }\n        w.skip();\n      }\n      return null;\n    });\n    // Not HTML tag -- returning\n    if (end === null)\n      return false;\n    // Emitting HTML tag\n    var w = new SubWalker(walk, walk.position, end);\n    while(w.hasCurrent())\n      this.emitHtmlTag(w);\n    walk.startFrom(end);\n    return true;\n  },\n\n  tryHtmlComment: function(walk) {\n    if (!walk.at(\"<!--\"))\n      return false;\n    var end = walk.lookahead(function(w) {\n      w.skip(4);\n      while(w.hasCurrent())\n        if (w.at(\"-->\"))\n          return w.position + 3;\n        else w.skip();\n      return null;\n    });\n    // Not HTML comment\n    if (end === null)\n      return false;\n    // Emitting like HTML tag\n    this.out.push(walk.yieldUntil(end));\n    return true;\n  },\n\n  emitHtmlTag: function(walk) {\n    if (this.emitText(walk)) return;\n    if (this.tryAmp(walk)) return;\n    if (this.tryLinkAttr(walk)) return;\n    this.emitChar(walk);\n  },\n\n  /* Some sensitive contexts require only ampersands escape. */\n\n  emitPlain: function(walk) {\n    if (this.emitText(walk)) return;\n    this.emitChar(walk);\n  },\n\n  /* The `>` char is straightforward, since unescaped cases\n   are already covered by HTML tags. */\n\n  tryGt: function(walk) {\n    if (!walk.at(\">\")) return false;\n    this.out.push(\"&gt;\");\n    walk.skip();\n    return true;\n  },\n\n  /* There are cases (code spans) when `<` is escaped unconditionally,\n   even if it denotes to HTML tag. */\n\n  tryLtEscape: function(walk) {\n    if (!walk.at(\"<\")) return false;\n    this.out.push(\"&lt;\");\n    walk.skip();\n    return true;\n  },\n\n  /* Bracing elements -- code spans, ems and strongs -- are processed\n   like logical parentheses. */\n\n  tryBracing: function(walk, openMarker, closeMarker, emitter) {\n    if (!walk.at(openMarker))\n      return false;\n    walk.skip(openMarker.length);\n    var end = walk.indexOf(closeMarker);\n    if (end === null) {\n      // just emit the open marker\n      this.out.push(openMarker);\n    } else {\n      // delegate rendering of subarea to emitter\n      var w = new SubWalker(walk, walk.position, end);\n      emitter.call(this, w);\n      walk.startFrom(end + closeMarker.length);\n    }\n    return true;\n  },\n\n  /* Triple code spans are emitted as is, only ampersands are escaped\n   inside. */\n\n  tryTripleCodeSpan: function(walk) {\n    return this.tryBracing(walk, '```', '```', function(w) {\n      this.out.push(\"<code>\");\n      while (w.hasCurrent())\n        this.emitPlain(w);\n      this.out.push(\"</code>\");\n    });\n  },\n\n  /* Regular code spans are processed by escaping amps, lt-gts, resolving\n   fragments and respecting backslash escapes. */\n\n  tryCodeSpan: function(walk) {\n    return this.tryBracing(walk, '`', '`', function(w) {\n      this.out.push(\"<code>\");\n      while (w.hasCurrent())\n        this.emitCode(w);\n      this.out.push(\"</code>\");\n    });\n  },\n\n  emitCode: function(walk) {\n    if (this.tryBackslashEscape(walk)) return;\n    if (this.tryAmp(walk)) return;\n    if (this.tryLtEscape(walk)) return;\n    if (this.tryGt(walk)) return;\n    this.emitChar(walk)\n  },\n\n  /* MathJax-friendly formulas are enclosed in `$$` or `%%` pairs.\n   Processing is similar to the one in code spans, except that\n   backslashes are emitted as-is. Markers are emitted too. */\n  tryFormula: function(walk) {\n    return this.tryFormulaM(walk, \"%%\") || this.tryFormulaM(walk, \"$$\");\n  },\n\n  tryFormulaM: function(walk, marker) {\n    return this.tryBracing(walk, marker, marker, function(w) {\n      this.out.push(marker);\n      while(w.hasCurrent())\n        this.emitFormula(w);\n      this.out.push(marker);\n    });\n  },\n\n  emitFormula: function(walk) {\n    if (this.tryAmp(walk)) return;\n    if (this.tryLtEscape(walk)) return;\n    if (this.tryGt(walk)) return;\n    this.emitChar(walk)\n  },\n\n  /* Ems and strongs are matched reluctantly up to their closing marker. */\n\n  tryEm: function(walk) {\n    return this.tryBracing(walk, '_', '_', function(w) {\n      this.out.push(\"<em>\");\n      while (w.hasCurrent())\n        this.emitNormal(w);\n      this.out.push(\"</em>\");\n    });\n  },\n\n  tryStrong: function(walk) {\n    return this.tryBracing(walk, '*', '*', function(w) {\n      this.out.push(\"<strong>\");\n      while (w.hasCurrent())\n        this.emitNormal(w);\n      this.out.push(\"</strong>\");\n    });\n  },\n\n  /* Links and images are resolved from supplied `options`. */\n\n  emitLink: function(text, link) {\n    var href = link.url\n      , external = link.external || this.options.externalLinks;\n    if (!href)\n      href = link.toString();\n    this.out.push(\"<a href=\\\"\" + href + \"\\\"\");\n    if (link.title)\n      this.out.push(\" title=\\\"\" + escapeHtml(link.title) + \"\\\"\");\n    if (external)\n      this.out.push(\" target=\\\"_blank\\\"\");\n    // Link text is rendered separately with the same options\n    var html = new InlineCompiler(this.options).toHtml(text);\n    this.out.push(\">\" + html + \"</a>\");\n  },\n\n  tryHeadlessLink: function(walk) {\n    if (!walk.at(\"[[\"))\n      return false;\n    walk.skip(2);\n    var end = walk.indexOf(\"]]\");\n    // ]] not found, emitting\n    if (end === null) {\n      this.out.push(\"[[\");\n      return true\n    }\n    var id = walk.yieldUntil(end);\n    var link = this.options.resolveLink(id);\n    if (!link) // Link not found, spitting as is\n      this.out.push(\"[[\" + id + \"]]\");\n    else this.emitLink(link.title, link);\n    walk.skip(2);\n    return true;\n  },\n\n  tryLink: function(walk) {\n    if (!walk.at(\"[\")) return false;\n    // Try to find the ]\n    walk.skip();\n    var start = walk.position;\n    // Also support nesting with images\n    var end = walk.lookahead(function(w) {\n      var nested = 0;\n      var found = false;\n      while (!found && w.hasCurrent()) {\n        if (w.at(\"\\\\\"))\n          w.skip(2);\n        else if (w.at('![')) {\n          nested += 1;\n          w.skip(2);\n        } else if (w.at(']')) {\n          if (nested == 0)\n            found = true;\n          else {\n            nested -= 1;\n            w.skip()\n          }\n        } else w.skip();\n      }\n      return found ? w.position : null;\n    });\n    if (end === null) {\n      this.out.push(\"[\");\n      return true;\n    }\n    // Collecting the text up to ] and matching further\n    var text = walk.yieldUntil(end);\n    walk.skip();\n    if (this.tryInlineLink(text, walk)) return true;\n    if (this.tryRefLink(text, walk)) return true;\n    // Nothing matched -- rolling back and processing text normally\n    walk.startFrom(start);\n    this.out.push(\"[\");\n    return true;\n  },\n\n  tryInlineLink: function(text, walk) {\n    if (!walk.at(\"(\")) return false;\n    var end = walk.indexOf(\")\");\n    if (end === null)\n      return false;\n    walk.skip();\n    var href = walk.yieldUntil(end);\n    walk.skip();\n    this.emitLink(text, href);\n    return true;\n  },\n\n  tryRefLink: function(text, walk) {\n    if (!walk.at(\"[\")) return false;\n    var start = walk.position;\n    walk.skip();\n    var end = walk.indexOf(\"]\");\n    if (end !== null) {\n      var id = walk.yieldUntil(end);\n      var link = this.options.resolveLink(id);\n      if (link) {\n        this.emitLink(text, link);\n        walk.skip();\n        return true;\n      }\n    }\n    // Not a reference link, rolling back\n    walk.startFrom(start);\n    return false;\n  },\n\n  emitImg: function(alt, link) {\n    if (link.html) {\n      this.out.push(link.html);\n      return;\n    }\n    var src = link.url;\n    if (!src)\n      src = link.toString();\n    this.out.push(\"<img src=\\\"\" + src + \"\\\" alt=\\\"\" + escapeHtml(alt) + \"\\\"\");\n    if (link.title)\n      this.out.push(\" title=\\\"\" + escapeHtml(link.title) + \"\\\"\");\n    this.out.push(\"/>\");\n  },\n\n  tryImg: function(walk) {\n    if (!walk.at(\"![\")) return false;\n    // Try to find the ]\n    walk.skip(2);\n    var start = walk.position;\n    var end = walk.indexOf(\"]\");\n    if (end === null) {\n      this.out.push(\"![\");\n      return true;\n    }\n    // Collecting the text up to ] and matching further\n    var text = walk.yieldUntil(end);\n    walk.skip();\n    if (this.tryInlineImg(text, walk)) return true;\n    if (this.tryRefImg(text, walk)) return true;\n    // Nothing matched -- rolling back and processing text normally\n    walk.startFrom(start);\n    this.out.push(\"![\");\n    return true;\n  },\n\n  tryInlineImg: function(text, walk) {\n    if (!walk.at(\"(\")) return false;\n    var end = walk.indexOf(\")\");\n    if (end === null)\n      return false;\n    walk.skip();\n    var src = walk.yieldUntil(end);\n    walk.skip();\n    this.emitImg(text, src);\n    return true;\n  },\n\n  tryRefImg: function(text, walk) {\n    if (!walk.at(\"[\")) return false;\n    var start = walk.position;\n    walk.skip();\n    var end = walk.indexOf(\"]\");\n    if (end !== null) {\n      var id = walk.yieldUntil(end);\n      var link = this.options.resolveImage(id);\n      if (link) {\n        this.emitImg(text, link);\n        walk.skip();\n        return true;\n      }\n    }\n    // Not a reference link, rolling back\n    walk.startFrom(start);\n    return false;\n  },\n\n  tryLinkAttr: function(walk) {\n    if (!walk.at(\"[\")) return false;\n    var start = walk.position;\n    walk.skip();\n    var end = walk.indexOf(\"]\");\n    if (end !== null) {\n      var id = walk.yieldUntil(end);\n      var link = this.options.resolveLink(id);\n      if (link) {\n        var url = link.url;\n        if (!url)\n          url = link.toString();\n        this.out.push(url);\n        walk.skip();\n        return true;\n      }\n    }\n    // Not a reference link, rolling back\n    walk.startFrom(start);\n    return false;\n  }\n\n};\n\n/* ## Regexes and constants */\n\nvar backslashChars = '\\\\.+*[]()`{}_!-|~\\'\"';\nvar latinLetters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nvar hexChars = \"0123456789abcdefABCDEF\";\nvar decimalChars = \"0123456789\";\nvar ampEscape = /&(?!(?:[a-zA-Z]+|#[0-9]+|#[xX][0-9a-fA-F]+);)/g;\n\n/* ## Utility stuff */\n\nfunction isInvalidXmlChar(code) {\n  if (typeof code == \"string\")\n    code = code.charCodeAt(0);\n  return (code >= 0x1 && code <= 0x8) ||\n    (code >= 0xB && code <= 0xC) ||\n    (code >= 0xE && code <= 0x1F) ||\n    (code >= 0x7F && code <= 0x84) ||\n    (code >= 0x86 && code <= 0x9F) ||\n    (code >= 0xFDD0 && code <= 0xFDDF) ||\n    (code % 0x10000 == 0xFFFE) ||\n    (code % 0x10000 == 0xFFFF);\n}\n\nfunction escapeHtml(text) {\n  return text\n    .replace(ampEscape, \"&amp;\")\n    .replace(\"<\", \"&lt;\")\n    .replace(\">\", \"&gt;\")\n    .replace(\"\\\"\", \"&quot;\")\n    .replace(\"\\'\", \"&#x27;\");\n}\n\nfunction unescapeHtml(text) {\n  return text\n    // >\n    .replace(\"&gt;\", \">\")\n    .replace(/&#[xX]3[eE];/, \">\")\n    .replace(\"&#62;\", \">\")\n    // <\n    .replace(/&[lL][tT];/, \"<\")\n    .replace(/&#[xX]3[cC];/, \"<\")\n    .replace(\"&#60;\", \"<\")\n    // \"\n    .replace(/&[qQ][uU][oO][tT];/, \"\\\"\")\n    .replace(/&#[xX]22;/, \"\\\"\")\n    .replace(\"&#34;\", \"\\\"\")\n    // '\n    .replace(/&[aA][pP][oO][sS];/, \"\\'\")\n    .replace(/&#[xX]27;/, \"\\'\")\n    .replace(\"&#39;\", \"\\'\")\n    // &\n    .replace(/&[aA][mM][pP];/, \"&\")\n    .replace(/&#[xX]26;/, \"&\")\n    .replace(\"&#38;\", \"&\");\n}\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/walker.js":"\"use strict\";\n\nvar extend = require(\"./extend\");\n\n/* # Generic character sequence walker\n\n `Walker` wraps `source` (string or another walker)\n and adds a common cursor, lookahead and other parser functionality.\n\n Walkers are supposed to be composed from either strings or another\n walkers. The catch is that no strings are actually copied --\n only indices. All operations inside are based on simple arithmetics.\n */\nvar Walker = exports.Walker = function(cs) {\n\n  this.source = cs || \"\";\n  this.position = 0;\n\n  this.length = this.source.length;\n\n};\n\nWalker.prototype = {\n\n  /* ## Character sequence\n\n   We define `length` property along with `charAt(i)`,\n   `substring(s, e)` and `toString()`\n   to make every walker behave like a string.\n\n   By convention character sequence variables are named `cs` are\n   only allowed to use these members.\n   */\n\n  // returns a character at `i`\n  charAt: function(i) {\n    if (i >= this.length)\n      return \"\";\n    return this.source.charAt(i);\n  },\n\n  // returns a substring in specified range `[s;e)`\n  substring: function(s, e) {\n    if (typeof(e) == 'undefined')\n      e = this.source.length;\n    return this.source.substring(s, e);\n  },\n\n  // returns a string representation of this walker\n  // (delegates to `source`)\n  toString: function() {\n    return this.source.toString();\n  },\n\n  /* ## Subregioning and exclusion\n\n   The `exclude` method returns another walker based off the current one,\n   cutting away a portion of text.\n   */\n  exclude: function(s, e) {\n    if (e - s == 0) // none\n      return this;\n    if (s == 0 && e == this.length) // everything\n      return new Walker(\"\");\n    if (s == 0) // minus prefix\n      return new SubWalker(this, e, this.length);\n    if (e == this.length) // minus postfix\n      return new SubWalker(this, 0, s);\n    // cut the middle out\n    var ws = new SubWalker(this, 0, s);\n    var we = new SubWalker(this, e, this.length);\n    return new MultiWalker([ws, we]);\n  },\n\n  /* ## Cursors\n\n   The `position` property is a simple zero-based index inside\n   a walker. Many methods make use of it to do the traversal stuff.\n   */\n\n  // returns a char under `position`\n  current: function() {\n    return this.charAt(this.position);\n  },\n\n  // checks if `current()` is applicable in current position\n  hasCurrent: function() {\n    return this.position >= 0 && this.position < this.length;\n  },\n\n  // checks if `step()` is allowed from current position\n  hasNext: function() {\n    return (this.position + 1) < this.length;\n  },\n\n  // forwards the `position` by specified `n`\n  skip: function(n) {\n    if (typeof n == 'undefined')\n      n = 1;\n    this.position += n;\n    return this;\n  },\n\n  // peeks a next char without modifying `position`\n  peek: function() {\n    return this.charAt(this.position + 1);\n  },\n\n  // resets `position` to zero\n  reset: function() {\n    this.position = 0;\n    return this;\n  },\n\n  // resets `position` to specified `i`\n  startFrom: function(i) {\n    this.position = i;\n    return this;\n  },\n\n  // executes a `fn` on current walker and returns its result,\n  // the initial `position` is restored once `fn` finishes\n  lookahead: function(fn) {\n    var oldPos = this.position;\n    var result = fn(this);\n    this.position = oldPos;\n    return result;\n  },\n\n  // walks to specified index `i`, returning a string\n  yieldUntil: function(i) {\n    if (i <= this.position)\n      return \"\";\n    var result = this.substring(this.position, i);\n    this.startFrom(i);\n    return result;\n  },\n\n  // walks up to next control symbol, returning a string\n  yieldText: function() {\n    var found = false;\n    var start = this.position;\n    while(!found && this.hasCurrent()) {\n      var c = this.current();\n      found = c == \"\" || c == \"\\\\\" || c == \"&\" || c == \"<\" ||\n        c == \">\" || c == \"`\" || c == \"$\" || c == \"%\" || c == \"_\" ||\n        c == \"*\" || c == \"!\" || c == \"[\" || c == \"(\" || c == \"{\" ||\n        c == \"-\" || c == \"\\\"\" || c == \"=\";\n      if (!found)\n        this.skip();\n    }\n    return this.substring(start, this.position);\n  },\n\n  // scrolls to the end of the current line\n  scrollToEol: function() {\n    while (this.hasCurrent() && !this.atNewLine())\n      this.skip();\n    return this;\n  },\n\n  // scrolls walker to the end of the block (EOL, followed by EOF or blank line)\n  scrollToTerm: function() {\n    var found = false;\n    while(this.hasCurrent() && !found) {\n      if (this.atNewLine()) {\n        var i = this.position;\n        if (this.skipNewLine().skipSpaces().atNewLine()) {\n          this.startFrom(i);\n          found = true;\n        } else this.skip();\n      } else this.skip();\n    }\n    return this;\n  },\n\n  // scrolls walker up to the next occurrence of specified `cs`\n  scrollTo: function(cs) {\n    while (this.hasCurrent() && !this.at(cs))\n      this.skip();\n    return this;\n  },\n\n  // scans forward, searching for `marker`, respecting backslashes,\n  // returns the index or `null` if marker not found\n  indexOf: function(marker) {\n    return this.lookahead(function(w) {\n      var found = false;\n      while (!found && w.hasCurrent()) {\n        if (w.at(\"\\\\\"))\n          w.skip(2);\n        else if (w.at(marker))\n          found = true;\n        else w.skip();\n      }\n      return found ? w.position : null;\n    });\n  },\n\n  /* ## Testing characters\n\n   Various methods are available to quickly test characters\n   at current cursor position.\n   */\n\n  // tests if cursor looks at specified `cs`\n  at: function(cs) {\n    var end = this.position + cs.length;\n    if (end > this.length) return false;\n    return this.substring(this.position, end) == cs;\n  },\n\n  // tests if cursor looks at specified `cs`, case insensitively\n  atInsensitive: function(cs) {\n    var end = this.position + cs.length;\n    if (end > this.length) return false;\n    return this.substring(this.position, end).toLowerCase() ==\n      cs.toLowerCase();\n  },\n\n  // tests if current char is in specified `arr`\n  matchSome: function(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (this.at(arr[i]))\n        return arr[i];\n    }\n    return null;\n  },\n\n  // tests if cursor looks at digit\n  atDigit: function() {\n    var c = this.current();\n    return c >= '0' && c <= '9';\n  },\n\n  // skips digits\n\n  skipDigits: function() {\n    while (this.atDigit())\n      this.skip();\n    return this;\n  },\n\n  // tests if cursor looks at latin letter\n  atLatin: function() {\n    var c = this.current();\n    return c >= 'A' && c <= 'z';\n  },\n\n  // tests if cursor is at [a-zA-Z0-9_-]\n  atIdentifier: function() {\n    var c = this.current();\n    return c >= '0' && c <= '9' || c >= 'A' && c <= 'z' || c == '_' || c == '-';\n  },\n\n  // tests if cursor is positioned towards a new line\n  atNewLine: function() {\n    return this.at(\"\\r\\n\") ||\n      this.at(\"\\n\") || this.at(\"\\r\");\n  },\n\n  // skips exactly one new line, if `atNewLine`\n  skipNewLine: function() {\n    if (this.at(\"\\r\\n\"))\n      this.skip(2);\n    else if (this.atNewLine())\n      this.skip();\n    return this;\n  },\n\n  // skips all new line tokens at cursor\n  skipNewLines: function() {\n    while (this.atNewLine())\n      this.skipNewLine();\n    return this;\n  },\n\n  // tests if cursor is positioned towards an inline-level space\n  atSpace: function() {\n    return this.at(\" \") || this.at(\"\\t\")\n  },\n\n  // tests if cursor looks at specified `count` of space chars\n  atSpaces: function(count) {\n    return this.lookahead(function(w) {\n      for (var i = 0; i < count; i++) {\n        if (!w.hasCurrent() || !w.at(\" \"))\n          return false;\n        w.skip();\n      }\n      return true;\n    });\n  },\n\n  // skips one space char if positioned towards one\n  skipSpace: function() {\n    if (this.atSpace())\n      this.skip();\n    return this;\n  },\n\n  // skips all spaces at current cursor\n  skipSpaces: function() {\n    while (this.atSpace())\n      this.skip();\n    return this;\n  },\n\n  // tests if cursor looks at any kind of whitespace\n  atWhitespace: function() {\n    return this.atNewLine() || this.atSpace();\n  },\n\n  // skips one whitespace char at cursor position\n  skipWhitespace: function() {\n    var p = this.position;\n    this.skipNewLine();\n    if (this.position == p)\n      this.skipSpace();\n    return this;\n  },\n\n  // skips all whitespace at current cursor position\n  skipWhitespaces: function() {\n    while(this.atWhitespace())\n      this.skip();\n    return this;\n  },\n\n  // skips lines containing only whitespace characters up to\n  // the beginning of the next line containing meaningful content\n  skipBlankLines: function() {\n    var finish = false;\n    while(this.hasCurrent() && !finish) {\n      var p = this.position;\n      this.skipSpaces();\n      if (this.atNewLine())\n        this.skipNewLines();\n      else {\n        this.position = p;\n        finish = true;\n      }\n    }\n    return this;\n  },\n\n  // skips to the end of the current line, returning it\n  readLine: function() {\n    var startIdx = this.position;\n    this.scrollToEol().skipNewLine();\n    return new SubWalker(this, startIdx, this.position);\n  }\n\n};\n\n/* # Subsequence walker\n\n `SubWalker` restricts the cursor to the portion of the source character\n sequence specified by `start` and `end` index.\n */\nvar SubWalker = exports.SubWalker = function(cs, start, end) {\n\n  this.source = cs;\n\n  this.start = start;\n  if (typeof(start) == \"undefined\" || this.start < 0)\n    this.start = 0;\n\n  this.end = end;\n  if (typeof(end) == \"undefined\" || this.end > cs.length)\n    this.end = cs.length;\n\n  this.length = this.end - this.start;\n\n};\n\nSubWalker.prototype = extend({}, new Walker, {\n\n  charAt: function(i) {\n    if (i >= this.length)\n      return \"\";\n    return this.source.charAt(this.start + i);\n  },\n\n  substring: function(s, e) {\n    if (typeof(e) == 'undefined')\n      e = this.length;\n    return this.source.substring(this.start + s, this.start + e);\n  },\n\n  toString: function() {\n    return this.source.substring(this.start, this.end);\n  }\n\n});\n\n/* # Multi sequence walker\n\n `MultiWalker` provides a virtual worker over specified `regions`.\n */\nvar MultiWalker = exports.MultiWalker = function(regions) {\n\n  if (Array.isArray(regions))\n    this.regions = regions;\n  else this.regions = [ regions ];\n\n  var l = 0;\n\n  this.regions.forEach(function(r) {\n    l += r.length;\n  });\n\n  this.length = l;\n\n  this.string = (function() {\n    var result = \"\";\n    for (var i = 0; i < this.regions.length; i++)\n      result += this.regions[i];\n    return result;\n  }).call(this);\n\n};\n\nMultiWalker.prototype = extend({}, new Walker, {\n\n  charAt: function(idx) {\n    return this.string.charAt(idx);\n  },\n\n  substring: function(s, e) {\n    if (this.regions.length == 0)\n      return \"\";\n    return this.string.substring(s, e);\n  },\n\n  toString: function() {\n    return this.string;\n  }\n\n});\n\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/extend.js":"\"use strict\";\n\nvar extend = module.exports = function() {\n  var target = arguments[0] || {}\n    , length = arguments.length;\n\n  if (typeof target != 'object') {\n    target = {}\n  }\n\n  for (var i = 1; i < length; i++) {\n    var aug = arguments[i];\n    if (!aug) continue;\n    for (var k in aug) {\n      var src = target[k];\n      if (typeof src == 'object') {\n        target[k] = extend(src, aug[k]);\n      } else target[k] = aug[k];\n    }\n  }\n\n  return target;\n\n};","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/async.js":"'use strict';\n\nvar defaults = require(\"./defaults\")\n  , html = require(\"html\")\n  , BlockCompiler = require(\"./block\")\n  , Walker = require(\"./walker\").Walker;\n\n/* # Asynchronous block compiler\n\n Unlike `BlockCompiler`, `AsyncCompiler` accepts callback\n which will be invoked once the computation is finished.\n\n Each block is computed in event queue.\n */\nvar AsyncCompiler\n  = module.exports\n  = exports\n  = function(options) {\n\n  this.options = require(\"./extend\")({}, defaults.options, options);\n\n};\n\n/* Async compiler operates through `render` which accepts\n `text` to render and callback, which is invoked once\n the rendering is over:\n\n ```\n var asyncCompiler = new AsyncCompiler();\n asyncCompiler.render(myText, function(err, html) {\n // Do something with rendered HTML\n });\n ```\n */\nAsyncCompiler.prototype = {\n\n  BlockCompiler: BlockCompiler,\n\n  render: function(text, done) {\n    var blockCompiler = new this.BlockCompiler(this.options, this);\n    var walk = new Walker(text);\n    this.nextTick(blockCompiler, walk, done);\n  },\n\n  nextTick: function(blockCompiler, walk, done) {\n    if (walk.hasCurrent()) {\n      blockCompiler.emitBlock(walk);\n      process.nextTick(this.nextTick.bind(this, blockCompiler, walk, done));\n    } else {\n      done(null, blockCompiler.outToString());\n    }\n  }\n\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/Gruntfile.js":"var fs = require(\"fs\")\n  , rho = require(\"./lib/rho\");\n\nvar texts = {\n  src: function(filename) {\n    return fs.readFileSync(filename, { encoding: 'utf-8' });\n  },\n  html: function(filename) {\n    return rho.toHtml(texts.src(filename));\n  }\n};\n\nmodule.exports = function(grunt) {\n\n  var pkg = grunt.file.readJSON('package.json');\n\n  grunt.initConfig({\n\n    pkg: pkg,\n\n    browserify: {\n      basic: {\n        src: ['lib/browser.js'],\n        dest: 'build/rho.js'\n      }\n    },\n\n    uglify: {\n      options: {\n        banner: '/*! Rho v.<%=pkg.version%> by <%=pkg.author%> */\\n'\n      },\n      build: {\n        src: 'build/rho.js',\n        dest: 'build/rho.min.js'\n      }\n    },\n\n    jade: {\n      compile: {\n        options: {\n          pretty: true,\n          data: {\n            texts: texts,\n            pkg: pkg\n          }\n        },\n        files: {\n          \"index.html\": \"pages/index.jade\",\n        }\n      }\n    }\n\n  });\n\n  grunt.loadNpmTasks('grunt-browserify');\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-jade');\n\n  grunt.registerTask('default', ['browserify', 'uglify', 'jade']);\n\n};\n","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/amd.js":"define(function(require, exports, module) {\n\n  exports.options = require(\"./defaults\");\n\n  exports.BlockCompiler = require(\"./block\");\n\n  exports.InlineCompiler = require(\"./inline\");\n\n  exports.toHtml = function(text) {\n    return new rho.BlockCompiler(this.options).toHtml(text);\n  };\n\n  exports.toInlineHtml = function(text) {\n    return new rho.InlineCompiler(this.options).toHtml(text);\n  }\n\n});","/home/travis/build/npmtest/node-npmtest-rho/node_modules/rho/lib/browser.js":"/* # Rho for browser */\n\nwindow.rho = {\n\n  options: require(\"./defaults\"),\n\n  BlockCompiler: require(\"./block\"),\n\n  InlineCompiler: require(\"./inline\"),\n\n  toHtml: function(text) {\n    return new rho.BlockCompiler(this.options).toHtml(text);\n  },\n\n  toInlineHtml: function(text) {\n    return new rho.InlineCompiler(this.options).toHtml(text);\n  }\n\n};\n"}